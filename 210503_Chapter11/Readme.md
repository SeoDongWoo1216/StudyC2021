## 11. 문자
프로그램에서 문자를 사용할때 항상 작은 따옴표를 붙여준다. <br>
컴파일러는 a를 변수명으로 해석하는 반면, 'a'는 문자 상수로 해석한다. <br>
그러나 이런 문자 표현법은 컴파일 후에는 약속된 정수 값인 아스키 코드 값으로 바뀌기 때문에 의미가 없다. <br>

예를들어, 문자 상수 'a'는 정수 값 97로 바뀐다. <br>
문자는 메모리에 저장되는 방식이 정수와 같다는 것을 추론할 수 있는데, int형 변수에 저장하고 정수처럼 연산할 수도 있다. <br>
즉, 문자 'a'를 %d로 출력하면 97로 출력하고, 97을 %c로 출력하면 아스키 코드 값인 97인 문자를 출력한다. <br>
결론적으로 문자 상수 'a'와 정수 97은 같은 데이터이며, 변환 문자열의 종류에 따라 출력 형태가 결정되는 것이다. <br>

-----------------------------------------------

### 아스키 코드
아스키 코드는 128개 문자를 0~127의 숫자 중에 각각 어떤 값으로 표현할지 정의한 것이다. 자주 사용하는 아스키 코드값은 대략 다음과 같다. <br>
```C
숫자 문자(10개) : '0' ~ '9'   
아스키 코드값 : 48 ~ 57
```

```C
대문자 알파벳(26개) : 'A' ~ 'Z'
아스키 코드 값 : 65 ~ 90
```

```C
소문자 알파벳(26개) : 'a' ~ 'z'
아스키 코드 값 : 97 ~ 122
```

```C
특수 문자(33개) : ' '(공백), '$', '&' ... 등등   
아스키 코드값 : 32, 36, 38
```

```C
제어 문자(33개) : '\0', '\t', '\n', '\r' ... 등등   
아스키 코드값 : 0, 9, 10, 13
```
<br>

대략 아스키 코드 값의 특징을 다음과 같이 알 수 있는데,
- 알파벳과 숫자는 각각 연속된 아스키 코드 값을 갖는다.
- 소문자가 대문자보다 아스키 코드 값이 크다.
- 제어 문자는 백슬래시와 함께 표시하며 출력할 때 그 기능을 수행한다.

이런 특징을 활용하여 대문자를 소문자로 바꾸는 예제를 살펴보자.

```C
// 알파벳의 대소문자 변환 원리
// a(97) - A(65)를 뺀 32를 더하고빼서 대소문자를 변환이 가능하다.

#include <stdio.h>

int main(void) 
{
	char small;
	char cap = 'G';					        // char형 변수 선언과 초기화

	if ((cap >= 'A') && (cap <= 'Z'))	    // 만약 문자열이 대문자범위라면(아스키코드값 A(65) ~ Z(90) 사이라면)
	{
		small = cap + ('a' - 'A');			// 대/소문자의 차이를 더해 소문자로 변환 
						// (cap의 아스키코드값) + (a(97) - A(65)) 값을 뺀 32의 값이 저장됨.
	}

	printf("대문자 : %c %c", cap, '\n');    // '\n'를 %c로 출력하면 줄이 바뀜.
	printf("소문자 : %c", small);

	return 0;
}


// 결과
대문자 : G
소문자 : g
```
<br>
예제를 살펴보면, <br>
문자 상수는 4바이트의 크기를 갖지만 아스키 코드 값이 0~127의 범위에 있으므로 2진수로 바꾸면 왼쪽 바이트는 0이되고 오른쪽 1바이트만 의미를 갖게된다. <br>
따라서 문자는 1바이트 크기의 char형 변수에 저장해 사용할 수 있다. <br>
컴파일러는 문자에서 아스키 코드 값을 갖는 오른쪽 1바이트만 변수에 저장하고 남는 바이트는 버린다. <br>

```C
문자 G : 00000000 00000000 0000000 01000111   // 0으로 가득한 3자리는 저장할 공간이 없으므로 버려지고, cap에 0100011이 저장된다.
```

cap에 저장된 문자가 대문자의 코드 값 범위에 속하는지 조건문을 통해 검사하고, 대문자이면 소문자로 바꾸어 변수 small에 저장된다. <br>
이때 대문자와 소문자의 아스키코드 값의 차이는 32인데, ('a' - 'A' => 97 - 65)를 통해 동적으로 구할 수 있다. <br>
따라서, 대문자 'G'에 'a' - 'A' 를 더해주면 소문자 'g'를 구할 수 있다. <br><br>

scanf("%c %c", cap, '\n'); 가 있는 예제 코드를 보면 줄이 바껴서 입력되는 것을 볼 수 있는데,<br>
제어 문자를 프로그램에서 상수로 쓸 때는 백슬래시와 제어 기능을 암시하는 문자를 사용한다. <br>
즉, 줄을 바꾸는 문자는 new line의 n을 따서 '\n'과 같이 표현한다. <br>
제어 문자는 형태가 없으므로 %c로 출력하면 해당 제어 기능이 수행된다. 따라서 cap에 저장된 문자를 출력 한 후에 줄을 바꿔준다. <br>

-----------------------------------------------

### scanf 함수를 사용한 문자 입력
scanf 함수로 문자를 입력할때는 %c 변환 문자를 사용한다. <br>
%c는 알파벳, 숫자 모양의 문자 등의 형태가 있는 문자를 입력하지만 공백이나 탭문자, 개행 문자와 같은 제어 문자도 입력하므로 기억하는 것이 좋다. <br>
이들 세 문자는 숫자를 입력할 때 값을 구분하기 위해 사용되지만 문자를 입력할때는 그 자체가 하나의 입력 데이터가 된다. <br>

```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	char ch1, ch2;

	scanf("%c%c", &ch1, &ch2);  // 2개의 문자를 연속 입력

	printf("[%c%c]\n", ch1, ch2);
	printf("%d, %d\n", ch1, ch2);
	
	return 0;
}

/*
문자를 2개입력하는데 경우의 수
1. as  처럼 2개의 문자를 같이 입력해서 엔터치는경우     => [as]출력
2. a s 처럼 1개 입력하고  띄어쓰기하고 1개 입력하는경우 => [a' ']출력
3. a 입력하고 엔터 입력하는 경우						=> [a    출력
*/

// 스페이스바와 엔터도 아스키코드값이있기때문에 문자로 처리하는 것을 기억하자.

// 결과
ab  
[ab]       => a와 b를 연속으로 입력하고 엔터 치는 경우
97, 98

a 
[a ]       => a와 공백( )을 연속으로 입력하고 엔터 치는 경우
97, 32

a
[a
]          => a만 입력하고 엔터를 치는 경우
97, 10
```
<br>

첫번째 실행결과는 문자 'a'와 'b'가 차례로 ch1, ch2에 저장되서 그대로 출력된다. <br>
두번째 실행결과는 문자 'a'가 ch1에 저장되고 공백 문자가 ch2에 저장된다. 실행결과의 [] 안에 공백이 출력된 것을 확인할 수 있다.  <br>
세번째 실행결과는 문자 'a'만 입력하고 바로 엔터를 눌렀지만, 엔터에 해당하는 문자인 개행 문자('\n')가 ch2에 저장된다. <br>
따라서 ch1에 입력돤 문자 'a'가 출력되고, ch2에 저장된 개행 문자가 출력되므로 줄이 바뀌어서 출력된 것을 확인할 수 있다. <br><br>

제어문자를 %c로 출력하면 제어 문자의 기능을 수행하므로 문자의 기능을 느끼지 못할수도 있다. <br>
이때 %d를 써서 각 변수에 저장된 문자의 아스키 코드 값을 출력하면 입력된 문자를 좀 더 명확히 확인 할 수 있다.<br>
공백 문자는 32, 개행 문자는 10을 출력한다. <br>

```C
int a, b;
scanf("%d %d", &a, &b);   // 이때 공백은 입력받는 a, b를 구분하는 용도로 사용.
printf("%d %d", a, b);

// 결과
2 3
2 3
```
2개의 int형 변수에 정수를 동시에 입력하는 경우, scanf 함수가 호출되어 키보드로 '10(공백)20'과 같이 입력하면 중간에 있는 공백 문자는 10과 20을 구분하는 용도로 쓰인다. <br>
그러나 %c는 문자를 입력하므로 스페이스바도 입력 대상이 된다. <br>

scanf함수는 %c 앞에 스페이스를 사용하면 문자도 분리하여 입력할 수 있는 특별한 기능이 있다. <br>
만약 스페이스바, 탭, 엔터를 제외해서 문자들만 사용하고 싶다면 %c앞에 앞의 3개 중 아무거나 추가하면 된다. <br>
이때는 보통 공백을 사용하는 것이 가장 쉬우므로 한 칸을 띄우고 입력을 받는다. <br>

```C
scanf(" %c %c", &ch1, &ch2);
```
이 경우 scanf 함수는 입력 문자 중에서 스페이스바, 탭, 엔터를 무시하고 그 외의 문자만 입력한다. <br>

-----------------------------------------------

### getchar 함수와 putchar 함수
scanf 함수는 문자 뿐만 아니라 숫자도 입력하는 기능이 포함되어있으므로 문자만 입력하는 함수에 비해 크기가 크다. <br>
따라서 문자만 입출력하는 함수인 getchar 함수와 putchar 함수를 알아보자. <br>

```C
int getchar(void);  // 매개 변수가 없고 입력한 문자를 반환
int putchar(int);   // 출력할 문자를 인수로 줌.
```

```C
#include <stdio.h>

int main() 
{
	int ch; 

	ch = getchar();              // scanf처럼 ch에 문자 하나를 입력받는 함수(실패하면 -1을 반환)
	printf("입력한 문자 : "); 
	putchar(ch);                 // 입력받은 ch를 출력
	putchar('\n');               // 그냥 개행용 putchar

	return 0;
}

/*
★★★★★★★
getchar를 받는 ch의 데이터타입이 int인 이유??
키보드입력값이 아스키코드 0~127 범위 내에있고, getchar가 문자 이외의 값도 반환하기 때문.
실패하면 -1를 반환하는데, 이것을 위해 int형으로 선언해주어야함.
★★★★★★★
*/

// 결과
A
입력한 문자 : A
```
<br>
getchar 함수는 매개변수가 없으므로 괄호만 사용하여 호출한다. <br>
호출된 함수는 키보드로 입력한 문자의 아스키 코드 값을 반환하므로 반환값은 int형 변수로 받는데, 반환 값은 필요에 따라 char형 변수나 배열에 옮겨서 문자나 문자열로도 사용한다.<br>
getchar 함수는 scanf함수와 마찬가지로 공백, 탭, 개행문자도 입력하는데 이들 문자를 제외하는 옵션은 없다. <br><br>

putchar 함수는 문자 상수나 문자의 아스키 코드 값을 인수로 주면 해당 문자를 화면에 출력한다. <br>
그리고 출력한 문자를 다시 반환하며 출력 과정에서 에러가 발생하면 -1을 반환한다. <br>

-----------------------------------------------
