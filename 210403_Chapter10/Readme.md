## 10. 배열과 포인터
- 배열을 출력하는 함수에 필요한 것은 배열명이다.
- 배열을 입력하는 함수에 필요한 것은 배열명이다.
- 배열의 크기가 달라도 입출력이 가능하려면 배열 요소의 개수(sizeof를 통해 구해보자)를 알아야한다.
<br>
배열은 자료형이 같은 변수를 메모리에 연속으로 할당한다. 따라서 각 배열 요소는 일정한 간격으로 주소를 갖게된다.<br>
예를들어, int ary[5];의 배열이 메모리 100번지부터 할당되고 int형 변수의 크기가 4바이트라면 각 배열 요소의 주소는 100, 104, 108, 112, 116번지가 된다. <br>
따라서 첫번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알 수 있고, 각 주소에 간접 참조 연산을 수행하면 모든 배열 요소를 사용할 수 있다.<br>
컴파일러는 첫번째 배열 요소의 주소를 쉽게 사용하도록 **배열명**을 컴파일 과정에서 **첫번째 배열 요소의 주소로 변경**한다. <br>

------------------------------------------------------------------------------

### 배열명으로 배열 요소 사용하기
주소는 자료형에 대한 정보를 갖고 있는 특별한 값이다.<br>
따라서 연산을 자유롭게 할 수 없고 정해진 연산만 가능하다. <br>
```C
주소 + 정수 => 주소 + (정수 * 주소를 구한 변수의 크기)
```
예를들어, int형 변수 a의 주소 100번지에 1을 더한 결과는 101이 아닌 104가 될것이다. <br>
이러한 연산 규칙은 배열을 사용할때 유용한데, 배열명도 주소이므로 정수를 차례로 더하면 연속된 배열 요소의 주소를 구할 수 있고, 여기에 간접 참조 연산을 수행하면 모든 배열 요소를 사용할 수 있다. <Br>
```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() 
{
	int ary[3];
	int i;

	// ★★★★★★★★★★★
	// ary[0] == *(ary + 0) 임
	//        == *주소   // 가 되기때문에 데이터를 나타냄
	// [ ] 를 풀어쓰면 *( ) 와 똑같음
	 
	// &ary 는 ary[0]와 같다.
	// 배열의 이름은 배열의 시작주소이기때문.
	// ★★★★★★★★★★★
	
	*(ary + 0) = 10;				// ary[0] = 10
	*(ary + 1) = *(ary + 0) + 10;   // ary[1] = ary[0] + 10

	printf("세번째 배열 요소에 키보드 입력 : ");
	scanf("%d", ary+2);              // &ary[2]

	for (i = 0; i < 3; i++)          // 모든 배열 요소 출력
	{
		printf("%5d", *(ary + i));   // ary[i] 의 값들을 출력
	}

	return 0;
}

// 결과
세 번째 배열 요소에 키보드 입력 : 30
  10  20  30
```
<br>
예제를 통해 배열의 대괄호 [] 는 포인터 연산의 '간접 찹조, 괄호, 더하기' 연산 기능을 갖는다는 것을 확인할 수 있다. <br>

```C
ary[1]  <->  *(ary + 1)
배열 요소 표현식  <->  포인터 연산식
```

따라서 배열 요소를 사용할때는 상황에따라 대괄호나 포인터 연산식 중 적당한 것을 골라서 싸용하면된다. <br>
특별한 경우가아니면 대괄호를 사용하는 것이 간단하고, &ary[2]와 같은 경우는 ary + 2 로 쓰면 연산과정을 줄일 수 있다.<br>

------------------------------------------------------------------------------

### 배열명 역할을하는 포인터
배열명은 주소이므로 포인터에 저장할 수 있다. <br>
이 경우 포인터로도 연산식이나 대괄호를 써서 배열 요소를 쉽게 사용할 수 있다. <br>
```C
#include <stdio.h>

int main() 
{
	int ary[3];					 // 배열 선언
	int* pa = ary;				 // 포인터에 배열명 저장
	int i;						 // 반복 제어 변수

	*pa = 10;				     // 첫 번재 배열 요소에 10대입

	*(pa + 1) = 20;				 // 두 번째 배열 요소에 20대입
	pa[2] = pa[0] + pa[1];       // 대괄호를 써서 pa를 배열명처럼 사용

	for (i = 0; i < 3; i++) 
	{
		printf("%5d", pa[i]);    // 포인터로 모든 배열 요소 출력
	}
}

// 결과
  10  20  30
```
예제에서 보듯이, 포인터가 배열명을 저장하면 배열명처럼 사용할 수 있다.
```C
pa[2] = pa[0] + pa[1]
*(pa + 2) = *(pa + 0) + *(pa + 1)     // 포인터 연산식
*(ary + 2) = *(ary + 0) + *(ary + 1)  // pa에 저장된 값은 ary
ary[2] = ary[0] + ary[0]              // 배열 요소 표현식
```
따라서 포인터에 배열명을 저장하면 포인터 연산을 통해 모든 배열 요소를 사용할 수 있으므로 포인터를 마치 배열명처럼 사용할 수 있다.

------------------------------------------------------------------------------

### 배열명과 포인터 차이
- sizeof 연산의 결과가 다르다.
- 변수와 상수의 차이가 있다.
<br>
sizeof 연산을 먼저 살펴보면,  <br>
포인터에 사용하면 포인터 하나의 크기를 구하고, 배열명에 sizeof를 사용하면 배열 전체의 크기를 구하게된다. <br>
따라서, 배열명을 포인터에 저장하면 포인터로 배열 전체의 크기를 확인하는 것이 불가능하다.<br>

```C
int ary[3];
int *pa = ary;
sizeof(ary)     // 12바이트, 배열 전체의 크기
sizeof(pa)      // 4바이트, 포인터 하나의 크기
```
<br>
그다음 변수와 상수의 차이를 살펴보면, <br>
**포인터**는 그 값을 바꿀 수 있지만, **배열명**은 상수이므로 값을 바꿀 수 없다.<br>
즉, 포인터 pa에 1을 더하여 다시 pa에 저장할 수는 있으나, 배열명 ary는 1을 더하는 것은 가능하지만 그 값을 다시 저장하는 것은 불가능하다.<br>

```C
pa = pa + 1   // 포인터는 바꿀 수 있다.
pa++
```

```C
ary = ary + 1  // 배열명은 값을 바꿀 수 없다.
ary++
```

```C
#include <stdio.h>

int main() 
{
	int ary[3] = { 10, 20, 30 };
	int* pa = ary;
	int i;

	printf("배열의 값 : ");
	for (i = 0; i < 3; i++)     // 
	{
		printf("%d ", *pa);     // pa가 가리키는 배열 요소 출력
		pa++;                   // 다음 배열 요소를 가리키도록 pa값 증가

		// 처음에서 ++을하면 두번째방의 요소를 출력하게됨
	}

	return 0;
}

// 결과
배열의 값 : 10 20 30
```

예제에서 포인터 pa로 첫번째 배열 요소를 출력하는 방법은 여러가지가 있는데,

```C
printf("%d", pa[0]);      // pa를 배열명처럼 사용해서 첫번째 배열 요소 출력
printf("%d", *(pa + 0));  // pa[0]을 그대로 포인터 연산식으로 바꾸는 방법
printf("%d", *pa);        // *(pa + 0)에서 의미 없는 0과 괄호를 제거한 표현 방법
```

<br>

표현 방법은 다르지만 3가지 모두 첫 번째 배열 요소를 출력한다. <br>
3번째의 경우 pa는 첫번째 배열 요소를 가리키므로 *pa의 연산식으로 첫번째 배열 요소의 값을 출력한다.<br>
만약 pa가 두번째 배열 요소를 가리키도록하면 같은 연산식으로 두 번째 배열요소의 값도 출력할 수 있다. <br>
이때 증감연산자를 사용해도 무관하다.(증감연산자와 간접참조연산자를 함 사용될때는 후위연산을 해야한다.) <br>

------------------------------------------------------------------------------

### 포인터의 뺄셈과 관계 연산
포인터에는 정수 덧셉이나 증가 연산 외에도 다양한 연산을 수행할 수 있다. <br>
예를들어, 가리키는 자료형이 같으면 포인터끼리의 뺄셈도 가능하다.

```C
포인터 - 포인터  =>  값의 차 / 가리키는 자료형의 크기
```

<br>

```C
#include <stdio.h>

int main() 
{
	int ary[5] = { 10,20,30,40,50 };
	int* pa = ary;				     // 첫번째 배열 요소 주소
	int* pb = pa + 3;                // 네번째 배열 요소 주소
	// 이때 pb는 ary[0]인 pa에서  +3을 통해 ary[4]가됨

	printf("pa : %u\n", pa);
	printf("pb : %u\n\n", pb);

	pa++;                               // pa++를 통해 pa는 0번방 -> 1번방으로 이동
	printf("pb - pa : %u\n", pb - pa);  // 3번방 - 1번방이니 2가 나옴
	
	printf("앞에 있는 배열 요소의 값 출력 : ");
	if (pa < pb) printf("%d\n", *pa);
	else printf("%d\n", *pb);

	return 0;
}

// 결과
pa : 15727644
pb : 15727656

pb - pa : 2
앞에 있는 배열 요소의 값 출력 : 20
```

<br>

이 예제는 포인터 pa와 pb로 배열 ary의 각각 다른 배열 요소를 가리키도록 한 후에 포인터의 뺄셈과 대소관계 연산을 수행하는 예제이다. <br>
따라서 위의 예제의 pb - pa는 다음과 같이 수행하게 된다. <br>

```C
pb - pa = (40 - 32) / sizeof(int)  =>  8 / 4 = 2     // (40 - 32)는 값의 차,  sizeof(int)는 자료형의 크기이다.
```

뺄셈의 결과는 배열 요소 간의 간격 차이를 의미한다. <br>
따라서 결과값으로 포인터 pa와 pb가 가리키는 배열 요소의 위치가 2개 떨어져있음을 알 수 있다. <br><br>

배열은 배열 요소가 메모리에 순서대로 할당되므로 앞의 배열 요소가 뒤의 배열 요소보다 주소 값이 작다. <br>
따라서 관계 연산의 결과로 두 포인터가 가리키는 배열 요소의 순서를 확인할 수 있게 된다. <br>

------------------------------------------------------------------------------
  
### 배열을 처리하는 함수
만약 함수로 배열을 처리하려면 포인터가 필요할것이다.<br>
ary배열에서 배열명 ary는 첫번째 배열요소의 주소인데, 이 주소값을 함수의 인수로 주면 함수는 이 값을받아 주소 계산을 통해 배열 요소를 사용할 수 있다. <br>
이때 배열명을 받을 함수의 매개변수 자리에 포인터가 필요하다. <br>
(배열명을 함수의 인수로 준다는것은 결국 int형 변수의 주소를 전달한다는 것이다.) <br>

------------------------------------------------------------------------------

### 배열의 값을 출력하는 함수
배열의 값을 확인하기 위해 수시로 출력해야 한다면, 그 기능을 함수로 만들어 호출하면 된다. <br>
이때 첫번째 배열 요소의 주소만 알면 나머지 배열 요소는 포인터 연산으로 모두 사용할 수 있다.<br>
따라서 함수를 호출할때는 배열명을 주고 함수의 매개변수로 포인터를 선언한다. 그리고 함수안에서 포인터를 배열명처럼 사용할 수 있다. <br>
즉, 배열명 자체가 주소이므로 그 값을 함수의 인수로 주는 것이 가능해진다. <br>

```C
#include <stdio.h>

void print_ary(int*);        // 함수 선언

int main() 
{
	int ary[5] = { 10, 20, 30, 40, 50 };

	print_ary(ary);          // 배열명을 주고 함수 호출

	return 0;
}


// 배열명을 줬으면 함수의 매개변수는 포인터나 배열로 받아야한다
void print_ary(int* pa)        
{
	int i;

	for (i = 0; i < 5; i++) 
	{
		printf("%d ", pa[i]);  // 배열의 요소 출력
	}
}

// 결과
10  20  30  40  50
```
위 예제를 살펴보면, <br>
메인함수에서 함수를 호출할때는 배열명을 주고 함수를 호출한다.  => print_ary(ary); <br><br>

배열명은 첫번째 배열요소의 주소이다. 첫번째요소가 int형이므로 int형 변수의 주소가 함수에 전달된다. <br>
따라서 int형을 가리키는 포인터 pa를 선언한다.  => void print_ary(int *pa); <br><br>

printf_ary 함수에서 ary배열에 관해 알고 있는 유일한 정보는 pa에 받는 첫번째 배열 요소의 주소밖에 없다. <br>
pa에 정수를 더하면 나머지 배열 요소의 주소를 구할 수 있고 간접 참조 연산으로 가리키는 배열 요소의 값도 사용할 수 있다. <br>

```C
정수 연산        :  pa + 1      // 두번째 배열 요소의 주소 104번지
간접 참조 연산   :  *(pa + 1)   // 두번째 배열 요소
배열 요소 표현식 :  pa[1]       // 두번째 배열 요소
```

<br>

따라서 print_ary 함수는 주소를 매개변수로 받아서 main함수에 있는 배열의 값을 출력한다. <br>
이와 같은 처리 방식은 배열에 있는 대량의 데이터를 다른 함수로 복사하지 않고 접근하므로 더 효율적이다. <br>
다만, 주소만 알면 해당 위치를 바꿀 수도 있으므로 의도치않게 값을 변형하는 일이 없도록 주의해야 할것이다. <br>

------------------------------------------------------------------------------

### 배열 요소의 개수가 다른 배열도 출력하는 함수
배열의 값을 출력하는 함수는 첫번째 배열 요소의 주소만 알면 되므로 배열 요소의 개수가 달라도 함수의 구현방법은 같다. <br>
다만 배열 요소의 개수가 바뀌면 출력문의 반복 횟수가 달라지므로 함수의 수정이 불가피해질 것이다. <br>

```C
#include <stdio.h>

void print_ary(int*, int);   // 매개변수가 2개인 함수 선언

int main() 
{
	// 각각 5, 7개의 요소를 가지는 배열 선언
	int ary1[5] = { 10, 20, 30, 40, 50 };   
	int ary2[7] = { 10, 20, 30, 40, 50, 60, 70 };  

	print_ary(ary1, sizeof(ary1) / sizeof(ary1[0]));  // sizeof 연산자를 이용하여 배열 요소의 개수를 동적으로 구함.
	printf("\n");
	print_ary(ary2, sizeof(ary2) / sizeof(ary2[0]));

	return 0;
}

// 첫번째 매개변수는 배열이름으로 받으니 포인터로 받아야한다.
void print_ary(int* pa, int size) // 배열명과 배열 요소의 개수를 받는 매개변수 선언
{
	int i;

	for (i = 0; i < size; i++)    // size값에따라 반복 횟수 결정
	{
		printf("%d ", pa[i]);
	}
}

// 결과
10 20 30 40 50
10 20 30 40 50 60 70
```
<br>
main 함수에서 같은 함수를 호출하여 다른 배열을 출력한다. (ary1과 ary1 배열 요소 개수 5, ary2와 ary2 배열 요소 개수 7)<br>
하지만 위의 예제에서는 함수 호출에 줘야하는 배열 요소 개수를 sizeof 연산자로 동적으로 구하여 print_ary 함수에 대입하였다. <br>
sizeof 연산자에 배열명을 사용하면 배열 전체의 크기를 계산하므로 이 값을 배열 요소 하나의 크기로 나누어 배열 요소의 개수를 구할 수 있다. <br>

------------------------------------------------------------------------------

### 배열에 값을 입력하는 함수
배열에 값을 **입력**하는 함수도 배열의 값을 **출력**하는 함수와 구현 방법이 같다. <br>
다만 입력 함수는 데이터를 저장할 배열의 위치가 필요하므로 함수 안에서 포인터를 직접 사용해야한다. <br>

```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

void input_ary(double* pa, int size);
double find_max(double* pa, int size);

int main() 
{
	double ary[5];
	double max;
	int size = sizeof(ary) / sizeof(ary[0]);

	input_ary(ary, size);
	max = find_max(ary, size);
	printf("배열의 최대값 : %.1lf\n", max);

	return 0;
}

void input_ary(double* pa, int size) 
{
	int i;

	printf("%d개의 실수값 입력 : ", size);
	for (i = 0; i < size; i++) 
	{
		scanf("%lf", pa + i);    // &pa[i]도 가능, 입력한 배열 요소의 주소를 전달
	}
}

double find_max(double* pa, int size) 
{
	// 최대값을 찾는 알고리즘 
	// : for문을통해 처음값과 다음값을 비교하고 만약 다음값이 더 크면 처음값을 넣어줌
	// 다음값과 다다음값을 비교하고 다다음값을 넣고... 반복
	double max;
	int i;

	max = pa[0];                   // 첫번째 배열 값을 최댓값으로 설정
	for (i = 1; i < size; i++)     // 두번째 배열 값부터 max와 비교
							       // i=0으로했을때 굳이 지자신과 비교할필요가 없기때문)
	{
		if (pa[i] > max) max = pa[i];  // 새로운 배열 요소의 값이 max보다 크면 대입해준다.
	}

	return max;                    // 최대값을 반환
}

// 결과
5개의 실수값 입력 : 3.4 0.5 1.7 5.2 2.0
배열의 최대값 : 5.2
```
<br>
위 예제는 double형 배열에 값을 입력하는 함수와 입력한 값 중에 최대값을 찾아서 반환하는 함수를 구현한 프로그램이다. <br>
다른 예제와 크게 다르지 않은데, pa에 i를 더해서 각 배열 요소의 주소를 구하고 그 값을 그대로 scanf 함수에 사용하는 특징이 있다. <br>
scanf 함수는 입력한 값을 저장할 배열의 위치를 알아야하므로 인수로 받은 pa의 값을 그대로 사용할 수 있다. <br>

------------------------------------------------------------------------------

