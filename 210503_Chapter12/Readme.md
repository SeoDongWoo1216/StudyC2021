## 12. 문자열
- 문자열은 주소(포인터)이다.
- 문자열은 첫 번째 문자가 저장된 메모리의 주소로 바뀐다.
- scanf 함수는 중간에 공백이 포함된 문자열을 입력할 수 없다.
- gets 함수는 한 줄의 데이터를 char 배열에 저장한다.
- fgets 함수는 배열의 크기를 검사하는 기능을 가진 문자열 입력 함수다.

--------------------------------------------------------------

### 문자열 상수 구현 방법
문자열은 크기가 일정하지 않다. 따라서 컴파일러는 문자열 상수를 독특한 방법으로 처리한다. <br>
컴파일 과정에서 문자열을 char 배열 형태로 따로 보관하고 문자열 상수가 있던 곳에는 배열의 위치 값을 사용한다. <br>
예를들어 문자열 "apple"은 문자 'a'가 저장된 메모리 주소 값으로 바뀌게된다.

```C
#include <stdio.h>

int main() 
{
	printf("저장할 문자열 : %s\n", "apple");
	printf("apple이 저장된 시작 주소 값 : %p\n", "apple");     // 주소 값 출력(인데 &가 없어도 주소값이 출력되는 것을 확인할 수 있다)
	printf("두 번째 문자의 주소 값 : %p\n", "apple" + 1);      // 주소 값 + 1 을 통해 두번째 문자 주소가 나옴
	printf("첫 번째 문자 : %c\n", *"apple");                   // 간접 참조 연산 *를 통해 시작주소의 데이터 출력
	printf("두 번째 문자 : %c\n", *("apple" + 1));             // 포인터 연산식을 통해 시작 주소의 그 다음 주소(두번째방)의 데이터 출력
	printf("배열로 표현한 세 번째 문자 : %c\n", "apple"[2]);   // 배열 표현식

	// 문자열 자체가 포인터, 주소 이기때문에 배열로도 사용가능. => 주소연산식, 배열연산식 사용가능
}

// 결과
저장할 문자열 : apple
apple이 저장된 시작 주소 값 : 003D7B30
두 번째 문자의 주소 값 : 003D7B31
첫 번째 문자 : a
두 번째 문자 : p
배열로 표현한 세 번째 문자 : p
```

<br>
첫번째 printf는 저장된 곳의 위치 값을 출력한다. 문자열 "apple"은 배열 형태로 따로 저장되고 printf함수의 인수로 그 첫번째 문자의 주소가 사용된다. <br>
printf 함수에서 %p로 출력하면 그 값을 16진수로 출력되는 것을 확인할 수 있다. <br><br>

결국 문자열은 컴파일 과정에서 char변수의 주소로 바뀌므로 직접 포인터 연산을 수행할 수 있다.<br>
문자에 정수를 더하면 다음 문자의 주소를 구할 수 있고, 간접 참조 연산을 수행하면 첫번째 문자가 된다.<br>
6번째 printf문처럼 배열로도 사용할 수 있는데, 주소로 접근하여 문자열을 바꿔서는 안된다. <br>
즉, *"apple" = 't'; 와 같이 첫번째 문자가 저장된 공간에 다른 문자를 대입하는 것은 위험한 시도이다. <br><br>

연산 자체는 문제가 없어서 정상적으로 컴파일되지만 실행할 때 운영체제에 의해 강제종료될 가능성이 높다. <br>
운영체제는 문자열 상수를 읽기 전용 메모리 영역에 저장한다. <br>
따라서 그 값을 바꾸는 명령을 제한하기때문에 위험한 시도가되는 것이다. <br><br>

문자열을 주소로 바꾸면 포인터 연산을 통해 문자열의 시작 위치부터 길이 제한없이 사용할 수 있다. <br>
이 경우 문자열의 끝을 알아야 하므로 문자열의 끝을 표시하기위해 NULL 문자를 사용한다. <br>
따라서 컴파일러는 문자열 상수를 따로 저장할 때 마지막에 항상 NULL문자를 붙여준다. <br>

--------------------------------------------------------------

### char 포인터로 문자열 사용
문자열은 주소이다. 따라서 문자열도 char 포인터에 대입하여 사용할 수 있다. <br>
문자열을 char 포인터에 대입하면 문자열에 이름을 붙여 사용할 수 있고 다른 문자열로 쉽게 바꿀 수 있다. <br>

```C
#include <stdio.h>

int main() 
{
	char *dessert = "apple";					 // 포인터에 문자열 초기화

	printf("오늘 후식은 %s입니다.\n", dessert);  // 문자열 출력
	dessert = "banana";		 // 새로운 문자열 대입(포인터 변수이므로 가능)
			   // char dessert = "apple"; 처럼 문자열 자체로 선언되있었으면 dessert에 바꿔서 대입하는것은 불가능

	printf("내일 후식은 %s입니다.\n", dessert);  // 바뀐 문자열 출력

	return 0;
}

//결과
오늘 후식은 apple입니다.
내일 후식은 banana입니다.
```

위 예제에서 char 포인터로 선언하고 문자열 상수로 초기화한다. <br>
문자열은 컴파일 과정에서 별도로 보관되고 첫번재 문자의 주소로 바뀌므로 결국 포인터에는 문자열의 시작 위치 값만 저장된다. <br>
그러나 포인터 연산을 통해 얼마든지 해당 문자열 전체를 사용할 수 있다. <br><br>

#### 같은 문자열 상수를 여러번 사용할때

```C
char *pa = "apple";
char *pb = "apple";
printf("%p, %p", pa, pb);
```

컴파일러는 같은 문자열을 여러번 사용한 경우 하나의 문자열만 메모리에 저장하고 그 주소를 공유하도록 번역한다. <br>
따라서 같은 문자열을 계속 사용해도 프로그램의 크기가 커지는일은 없다. <br><br>

단, 컴파일러가 메모리 사용을 줄이려는 최적화기능이므로 컴파일러가 다르게 구현될 수 있으므로  <br>
소스코드에 같은 문자열을 두 번 이상 사용하고 그 주소를 출력하고 같은 값인지를 살펴보는 것이 중요하다. <br><br>

#### %s의 실제 실행 방식
printf의 %s 변환 문자는 포인터 연산으로 문자열을 출력한다. 따라서 다음 코드와 같은 일을 수행한다. <br>

```C
while (*dessert != '\0')   // dessert 라는 문자열을 가리키는 문자가 NULL 문자가 아닌 동안
{
     putchar(*dessert);    // dessert가 가리키는 문자 출력
     dessert++;            // dessert로 다음 문자를 가리킨다.
}
```
위위 예제에서 dessert에 다른 문자열을 대입해서 dessert는 문자열 "banana"의 위치를 기억하며 이후부터 "banana"로 사용할 수 있다. <br>

--------------------------------------------------------------

### scanf 함수를 사용한 문자열 출력
문자열 상수는 값을 바꿀 수 없으므로 바꿀 수 있는 문자열을 원한다면 char 배열을 사용해야한다. <br>
배열에 문자열을 입력하는 방법은 다양한데, 일단 scanf 함수를 사용해보자. <br><br>

scanf함수는 %s를 사용하여 공백이 없는 연속된 문자들을 입력받는다.

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main() 
{
	char str[80];

	printf("문자열 입력 : ");
	scanf("%s", str);
	printf("첫 번째 단어 : %s\n", str);
	scanf("%s", str);
	printf("버퍼에 남아 있는 두번째 단어 : %s\n", str);
}

// 결과
문자열 입력 : apple jam(엔터)
첫 번째 단어 : apple
버퍼에 남아 있는 두번째 단어 : jam
```

scanf 함수는 버퍼를 사용하므로 키보드로 입력한 문자열은 엔터를 누를때 버퍼에 저장된다. <br>
그 후에 scanf 함수는 버퍼에서 문자열을 가져와 배열에 저장하는데 중간에 공백문자, 탭, 개행문자가 있으면 그 이전까지만 저장한다. <br><br>

실행결과에서 공백문자를 포함해 apple jam 이라고 입력한 경우를 예를 들어보자.<br>
버퍼에는 apple jam\n  로 저장되는데 <br>
첫번째 scanf는 띄워쓰기 전까지인 apple만 받기때문에 출력하면 apple만 출력된다. <br>
두번째 scanf는 버퍼에 jam이 남아있으므로 더 입력받지않고 printf를통해 남은 jam이 출력된다. <br><br>

scanf함수는 문자열을 저장할 배열의 크기를 알지 못하는데, scanf함수는 시작주소인 배열명을 인수로 받으므로 오로지 배열의 시작위치만 알고있다. <br>
그 주소를 증가시키면서 버퍼로부터 가져온 문자열을 배열에 저장하는데,  <br>
만약 배열의 크기보다 큰 문자열을 입력하면 포인터 연산을 통해 할당된 메모리 공간을 넘어서 저장한다. <br>
이 경우, 메모리 침범이 발생하므로 프로그램에러가 발생하게된다. <br>
따라서 scanf 함수로 문자열을 입력할때는 NULL 문자까지 고려하여 배열의 크기를 넘지 않도록 주의해야한다. <br><br>

--------------------------------------------------------------

### gets 함수를 사용한 문자열 입력
scanf 함수는 중간에 공백이 포함된 문자열을 한번에 입력할 수 없다. <br>
하지만 공백을 넣어야할때가 있는데, 이때는 gets 함수를 사용한다. <br>
gets 함수는 중간의 공백이나 탭 문자를 포함하여 문자열 한 줄을 입력한다. <br>

```C
// gets 함수 원형
char *gets(char *str)
```

```C
#include <stdio.h>

int main() {
	char str[80];
	printf("공백이 포함된 문자열 입력 : ");
	gets(str);
	printf("입력한 문자열은 %s입니다.", str);

	return 0;
}

// 결과
공백이 포함된 문자열 입력 : apple jam (엔터)
입력한 문자열은 apple jam입니다.
```

gets는 엔터를 누를때까지 입력한 한줄을 char배열에 저장한다. <br>
gets함수에 scanf와 똑같이 apple jam엔터 를 입력하면 그대로 저장되는데, 끝에있는 엔터(개행)문자를 NULL문자(\0)로 바꿔준다. <br>

--------------------------------------------------------------

### fgets 함수를 사용한 문자열 입력
scanf 함수와 gets 함수는 입력되는 문자열의 크기가 배열 크기를 넘어설 위험성이 있다. <br>
문자열의 크기가 배열보다 커지면 할당되지 않은 메모리 공간을 침범하여 실행 중인 프로그램에 에러가 발생할 수 있다. <br>
안전하게 문자열을 입력하려면 배열 크기를 확인하는 fgets 함수를 사용하는 것이 좋다. <br>
fgets 함수는 최대 배열의 크기까지만 문자열을 입력한다. <br>


```C
#include <stdio.h>

int main() 
{
	char str[80];

	printf("공백이 포함된 문자열 입력 : "); 
	fgets(str, sizeof(str), stdin);
	// 나중에 입력할 공간
	printf("입력된 문자열은 %s입니다.", str);

	return 0;
}

// 결과
공백이 포함된 문자열 입력 : apple jam
입력된 문자열은 apple jam
입니다.
```
fgets 함수는 문자열을 저장할 배열명 외에 배열의 크기와 표준 입력 버퍼를 뜻하는 stdin을 함께 사용한다. <br>
fgets 함수는 인수를 3개를 사용하는데 다음과 같다.
```C
fgets(str, sizeof(str), stdin);
```
str : 배열명 <br>
sizeof(str) : 배열의 크기 : 입력한 문자열의 끝에는 항상 null문자를 붙이므로 최대로 '배열의 크기 - 1개'의 문자만을 저장한다. <br>
stdin(표준입력) : 데이터를 입력할때 키보드와 연결된 표준 입력 버퍼를 뜻한다. <br>
fgets 함수가 입력 버퍼를 선택할 수 있는 함수이므로 키보드로 입력할 때는 항상 stdin을 넣어야한다. <br>
(참고로, scanf와 gets함수는 기본적으로 표준입력을 사용한다) <br><br>

fgets 함수가 문자열을 입력하는 방식은 gets 함수와 거의 같으나 개행 문자의 처리방식이 다르다는 것을 알 수 있다. <br>

--------------------------------------------------------------

### 표준 입력 함수의 버퍼 공유 문제
scanf 함수나 getchar 함수 같은 표준 입력 함수는 입력 버퍼를 공유한다. <br>
따라서 같은 버퍼를 공유하는 gets나 fgets 함수에서 개행 문자를 입력의 종료 조건으로 사용하면 문제를 일으킬수도 있는데, <br>
앞서 입력한 함수가 버퍼에 개행 문자를 남겨 놓은 경우, 이어서 호출되는 함수가 버퍼에서 개행 문자만 가져오고 입력을 끝내는 문제가 생기기 때문이다. <br>

```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() 
{
	int age;
	char name[20];

	printf("나이 입력 : ");
	scanf("%d", &age);
	// fgetc(stdin);
	printf("이름 입력 : ");
	gets(name);
	printf("\n나이 : %d\n이름 : %s\n", age, name);

	return 0;
}

// 결과
나이 입력 : 17 (엔터)
이름 입력 : 나이 : 17, 이름
```
위 예제에서 버퍼에서 개행 문자를 가져와 입력을 끝내므로 키보드로 이름을 입력하는 과정이 생략되면서 name 배열의 첫번째 요소에는 null문자가 저장되어서 출력이안된다. <br> 
이 문제는 입력 함수들이 버퍼를 공유해서 생기는 것이므로 필요할때 버퍼의 내용을 지워야한다. <br><br>

이럴때는 개행문자를 읽어들이는 문자 입력 함수를 호출하면 된다. <br>
```C
scanf("%*c");, getchar(), fgetc(stdin);
```
scanf는 버퍼에서 하나의 문자를 읽어서 버림으로써 변수가 필요없다. <br>
getchar()는 버퍼에서 하나의 문자를 읽어서 반환하여 반환문자를 버려준다. <br>
fgetc는 버퍼에서 하나의 문자를 읽어서 반환하여 반환 문자를 버려준다. <br><br>

따라서 위 예제에서 fgetc(stdin); 을 추가해서 컴파일해보면 이름을 입력받고 제대로 출력된다. <br>

--------------------------------------------------------------

### 문자열 출력하는 puts, fputs 함수
화면에 문자열만을 출력할때는 전용 출력 함수인 puts와 fputs를 사용한다. <br>

```C
puts 함수 원형  => int puts(const char *str)  // 문자열을 출력하고 자동으로 줄 바꿈
fputs 함수 원형 => int fputs(const char *str, FILE *stream);  // 문자열을 출력하고 줄 바꾸지 않음
```

```C
#include <stdio.h>
int main() 
{
	char str[80] = "apple juice";
	char* ps = "banana";

	puts(str);          // 자동개행해주는 출력함수
	fputs(ps, stdout);  // 개행기능없는 출력함수
	puts("milk");       

	return 0;
}

// 결과
apple juice
bananamilk
```
puts와 fputs 함수는 문자열의 시작 위치부터 널 문자가 나올 때까지 모든 문자를 출력한다. <br>
따라서 char 배열의 배열명이나 문자열 상수를 연결하고 있는 포인터를 인수로 줄 수 있다. <br>
물론 milk를 준것처럼 문자열 상수를 직접 사용하는 것도 가능하다. <br><br>

puts 함수는 fputs 함수와는 다르게 문자열을 출력한 후에 자동으로 줄을 바꿔주므로 편리하지만 줄을 바꾸고 싶지 않을때는 적당하지는 않다. <br>
실행결과를 보면 apple juice는 puts로 출력하여 출력 후 자동으로 줄이 바뀌었지만, <br>
banana는 fputs로 출력하여 banana가 출력된 후에 milk가 띄어쓰기없이 바로 이어서 출력된 것을 확인할 수 있다. <br>

--------------------------------------------------------------

### 실습) 로또프로그램

```C
/*
1. 로또 번호를 저장할 수 있는 배열을 선언(lotto[6])
2. 로또번호 입력 (동일한 번호 입력시 에러 메세지 출력하고, 그 부분부터 다시입력받기)
3. main에서 input_lotto(), print_lotto() 함수 선언

바로입력된값을 배열에 저장하지말고 입력된거를 임시변수를 사용해서
같으면 빠져나와서 다시 입력하라고함
*/

#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

input_lotto(int*,int);
print_lotto(int *, int);

int main()
{
	int lotto[6];
	int size = sizeof(lotto) / sizeof(lotto[0]);

	input_lotto(lotto, size);
	print_lotto(lotto, size);
}

input_lotto(int* iAry, int size) 
{
	int i, j, temp;
	
	for (i = 0; i < 6; i++)
	{
		printf("%d 번째 입력 : ", i + 1);
		scanf("%d", &temp);

		// 로또번호 0~45 숫자만 입력했는지 검사
		if ((temp <= 0) || (temp > 45))
		{
			printf("0~45까지의 수가 아닙니다. 다시입력하세요\n");
			i--;
			continue;
		}

		// 첫번째는 비교할 lotto가 없으니 그대로 삽입
		if (i == 0)
		{
			iAry[i] = temp;
		}

		// 로또배열 중복검사
		for (j = 0; j < i; j++)
		{
			if (temp == iAry[j])
			{
				printf("중복됩니다. 다시입력하세요\n");
				i -= 1;
				break;  // ★★★
			}
			else
			{
				iAry[i] = temp;
			}
		}
	}
}


// 로또배열 출력
print_lotto(int *iAry, int size) 
{
	int i;
	for (i = 0; i < 6; i++)
	{
		printf("%d ", iAry[i]);
	}
}

// 결과
1 번째 입력 : 2
2 번째 입력 : 5
3 번째 입력 : 6
4 번째 입력 : 40
5 번째 입력 : 30
6 번째 입력 : 7
2 5 6 40 30 7
```

