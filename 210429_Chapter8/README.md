# 8. 배열
C에서 배열은 시작주소와 for문을 기억하면된다.

-----------------------------------

## 8-1 배열의 선언과 사용
```C
int a, b, c, d, e;  //  변수 5개 선언
```
이대로 변수 5개를 선언하면 스택에 a, b, c, d, e가 제각각 멀리서 저장된다. <br>
이렇게 따로따로 선언하게되면 이름이 별도로 따로있기때문에 같은 형태의 많은 데이터를 처리하기가 불편해질것이다. <br>
따라서 배열을 통해 메모리에 데이터를 연속적으로 저장해놓고 쪼개서 사용하는 방법을 사용한다. <br><br>


```C
// 배열 선언
int a[5];   // int형 방을 메모리에 5개를 예약함(int가 4byte이므로 한 방에 4바이트라고 할 수 있다)
```
배열도 자료형처럼 선언을통해서 저장공간을 확보하는데, 5개의 이름을 하나씩 선언하는것이 아니라 하나의 이름으로 한꺼번에 확보한다는 특징이있다. <br>
또, 저장공간의 개수와 상관없이 이름은 하나만 사용한다. <br><br>


```C
// 배열의 초기화
int ary[5] = {1, 2, 3, 4, 5};  // 자료형, 배열명, [요소개수]로 초기화해줄 수 있다.
```
배열의 값을 할당해줄때 선언과 동시에 { }에 요소를 넣어서 초기화할 수 있다. <br><br>

```C
// 배열의 사용
int ary[5];
ary[0] = 10;   // ary[0]은 배열의 첫번째 요소를 뜻한다.
ary[1] = 20;   // 두번째 요소에 20대입
ary[2] = 30;
scanf("%d", &ary[3]);    // 키보드로 입력받은 값을 네번째 요소에 저장
printf("%d\n", ary[1]);  // %d로 출력하고, 배열의 요소를 지정해주어야한다.
```
<br>

#### 배열의 첨자가 사용범위를 벗어났을때?

만약 5개의 방으로 선언했는데 ary[6] 처럼 사용범위를 벗어나면 할당된 영역을 벗어난 메모리를 사용하므로 침범한 영역이 어떤 용도로 사용되느냐에따라 결과가 달라진다.<br>
이 경우, 컴파일러가 에러로 알려주기도 하지만 배열 요소에 포인터 연산을 통해 접근하기때문에 확실한 에러 메세지를 표시하지 않는다.<br>
이렇게 범위를 벗어난 영역에 접근하는 배열 코드는 실행단계에서 문제를 일으켜야 발견할 수 있는 에러이므로 버그를 잡기가 쉽지않다.<br>
따라서 사용범위를 벗어나지 않도록 주의하도록 하자. <br><br>


```C
// 배열 사용예제
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() 
{
	int ary[5];                // int형 요소 5개의 배열 선언
							   // ary는 array의 축약어
	ary[0] = 10;               // 첫번째 배열 요소에 10 대입
	ary[1] = 20;               // 두번째 배열 요소에 20 대입
	ary[2] = ary[0] + ary[1];  // 첫번째, 두번째 요소를 더해 세번째 요소에 저장

	printf("ary[3]에 저장할 정수를 입력해주세요 : ");
	scanf("%d", &ary[3]);      // 키보드로 입력받아 네번째 요소에 저장

	printf("%d\n", ary[2]);    // 세번째 배열 요소 출력
	printf("%d\n", ary[3]);
	printf("%d\n", ary[4]);    // 마지막 배열 요소는 쓰레기 값
}

// 결과
50
30
50
-858993460
```

-----------------------------------

### 배열과 반복문
배열은 연속된 저장 공간을 할당하고, 같은 유형의 변수가 많이 필요할때 사용한다.(for문을 사용한다)

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main() {
	int score[5];
	int i;
	int total = 0;
	double avg;

	for (i = 0; i < 5; i++)          // i가 0부터 4까지 5번 반복
	{
		scanf("%d", &score[i]);      // 각 배열 요소에 성적 입력
	}

	for (i = 0; i < 5; i++)          // 성적을 누적하여 총점 계산
	{
		total += score[i];           // 평균 계산(score[0] ~ score[4] 까지 합계산)
	}
	avg = total / 5.0;

	for (i = 0; i < 5; i++) 
	{
		printf("%3d", score[i]);
	}

	printf("\n");

	printf("평균 : %.1lf\n", avg);   // 평균 출력

	return 0;
}
// 결과
80 95 77 84 100
  80     95     77    84    100
평균 : 87.2
```

배열 입출력 for문으로 한다는것만 기억해두자.

-----------------------------------

### siezeof 연산자를 활용한 배열처리
배열을 처리할때는 반복문 사용이 필수적인데, 배열 요소의 개수가 바뀌면 배열을 처리할 반복문을 모두 수정해야하는 부담이 있다.<br>
이 경우 배열 요소를 직접 sizeof를 통해 동적으로 계산해서 반복문에 사용하는 방법이 있다. <br>
```C
sizeof(배열명) / sizeof(배열요소)  // 배열의 요소 구하기
```
<br> 위에서 for문을 사용했던 예제에서 조건문을 sizeof로 바꿔보자.<br>
```C
// sizeof 연산자를 사용한 배열
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main(void) {
	int score[5];
	int i;
	int total = 0;
	double avg;        
	int count;                      // 배열 요소의 개수를 저장할 변수
	
	// printf("sizeof(score) 크기      : %d\n", sizeof(score));    // 배열 전체 크기
	// printf("sizeof(score[0])의 크기 : %d\n", sizeof(score[0])); // 배열 한 방의 데이터 크기(int형이니 4 출력)

	count = sizeof(score) / sizeof(score[0]);  // ★배열 요소의 개수 계산★
	// 이렇게 동적으로 코드를 짜야 고급스러운 코드가 되는것임

	for (i = 0; i < count; i++)     // 11행에서 계산한 count만큼 반복
	{
		scanf("%d", &score[i]);
	}

	for (i = 0; i < count; i++)     // 11행에서 계산한 count만큼 반복 
	{
		total += score[i];
	}

	avg = total / (double)count;    // 총합을 count로 나누어 평균 계산(int / int형이기때문에 double로 강제형변환(하나만 해도 자동으로형변환이됨))

	for (i = 0; i < count; i++)     // 11행에서 계산한 count만큼 반복
	{
		printf("%4d", score[i]);   
	}
	printf("\n");

	printf("평균 : %.1lf\n", avg);
	
}

// 결과
80 95 77 84 100
  80     95     77    84    100
평균 : 87.2
```

배열을 선언하면 많은 변수를 한번에 선언하는 효과를 볼 수 있고, 초기화할때는 {}, 처리할때는 반복문을 사용하고, 크기를 구할때는 sizeof 연산자를 사용하는 것을 기억해두자. <br>

-----------------------------------

## 8-2 문자를 저장하는 배열
배열은 연속적으로 데이터를 저장하는데, 문자나 문자열을 처리할때 사용하는 것이 가장 좋은 방법이라고 할 수 있다. <br>

-----------------------------------

### char형 배열의 선언과 초기화
char형 배열을 선언할때 저장할 문자열의 길이보다 최소한 하나 이상 크게 배열을 선언해야한다. <br>
이 여분의 공간이 필요한 이유는 NULL 문자(\0)를 저장하기 위해서이다. <br>
우리가 평소에 문장을 끝내고 마침표를 찍듯이, 문자 배열을 선언했을때는 맨끝에는 항상 NULL문자가 와야한다. <br>

```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() 
{
	char str[80] = "applejam";              // char 80개 배열선언(80바이트)과 초기화

	printf("최초 문자열 : %s\n", str);      // 초기화 문자열 출력(문자열이라 %s 사용)
	printf("문자열 입력 : ");
	scanf("%s", str);                       // 문자열을 scanf를 통해 키보드로 입력받음
					// scanf함수가 문자열 이외의 방을 null문자를 자동으로 입력해줌.
	                               
	printf("입력 후 문자열 : %s\n", str);   // 입력된 문자열 출력
	
	return 0;
}

// 결과
최초 문자열 : applejam
문자열 입력 : grape
입력 후 문자열 : grape
```

char형 배열은 배열요소의 형태가 char일뿐, int형 배열과 다르지 않기때문에 초기화도 중괄호를 사용하여 문자를 차례로 나열하면된다.<br>
그러나 문자 상수로 초기화하는것은 귀찮으니 문자열 상수로 초기화하는 방법을 많이 사용한다. <br>
```C
char str[80] = {'a', 'p', 'p', 'l', 'e'};   // 문자 상수로 하나씩 초기화
char str[80] = "apple";                     // 문자열 상수로 하나씩 초기화
```

-----------------------------------

### NULL 문자의 용도?
char형 배열에서 초기화한 문자들은 배열의 처음부터 차례로 저장되서 문자열을 만든다. 이때, 남는 배열 요소에는 자동으로 0이 채워진다. <br>
이렇게 저장된 0을 특별히 **NULL 문자** 라고 부른다.  <br>
모든 문자는 아스키 코드 값으로 저장되므로 NULL 문자는 아스키코드 값이 0인 문자를 말하며 문자 상수로는 \0으로 표현된다. <br>
이때 NULL 문자는 문자열의 끝을 표시하는 용도로 사용한다. <br>
위의 예제에서 printf("최초 문자열 : %s\n", str);  처럼 배열 요소를 지정하지않았는데도 applejam이 그대로 출력되었는데, printf 함수 자체가 char형 배열에서 널 문자가 나올때까지만 출력하도록 만들어졌기때문에 문자열을 그대로 출력할 수 있다.(이러한 규칙은 문자열을 처리하는 모든 함수에 적용된다) <br>
```C
printf("문자열 : %s\n", str);  // 초기화 문자열 출력
scanf("%s", str);             // scanf함수도 문자열을 입력받을 수 있다. 이때 &은 필요없다는 것에 주목하자.
```
<br>

#### char형 배열시 초기화하지 않은 경우
char형 배열을 선언했을때 초기화하면 배열 요소가 0으로 채워지므로 자동으로 문자열의 끝에 NULL문자가 저장되나,<br>
초기화되지 않은 상태에서 배열 요소에 문자를 직접 대입한다면 반드시 마지막 문자 다음에는 NULL문자를 대입해주어야한다.<br>
```C
char str[80];    // 배열 선언, 초기화는 하지않음.
str[0] = 'a';    // 배열 요소에 직접 문자 대입
str[1] = 'p';    
str[2] = 'p';
str[3] = 'l';
str[4] = 'e';
str[5] = '\0';   // 마지막 문자 다음에 반드시 NULL 문자 대입!
```

char형 배열을 선언할때는 배열의 크기를 항상 넉넉하게 선언해야하고, 배열 요소의 개수는 최소 '문자열길이 + 1'이어야 하는 것을 기억해두자.<br>

-----------------------------------

### 문자열 대입
char형 배열이 문자열을 저장하는 변수의 역할을하므로 초기화된 이후에도 새로운 문자열을 저장할 수 있다. <br>
단, 문자열의 길이가 다를 수 있으므로 일반 변수처럼 대입연산자를 사용하는것은 불가능하다. 이때 strcpy(string copy의 약자)함수를 사용한다. <br>
```C
strcpy(저장될 배열명, 저장할 문자열);
```
<br>
strcpy 함수는 char형 배열에 새로운 문자열을 저장하는 함수로, 저장할 문자열의 길이를 파악하여 딱 그 길이 만큼한 char형 배열에 복사해준다. <br>
이때 문자열 끝에 NULL문자도 자동으로 붙여준다. <br>

```C
// 문자열을 복사해주는 strcpy 함수

#define _CRT_SECURE_NO_WANINGS
#include <stdio.h>   // 문자열 관련 함수 원형을 모아놓은 헤더파일

int main() 
{
	char str1[80] = "cat";
	char str2[80];

	strcpy(str1, "tiger");           // str1 파일에 "tiger" 복사
	strcpy(str2, str1);              // str2 배열에 str1 배열의 문자열 복사

	printf("%s, %s\n", str1, str2);

	return 0;
}

// 결과
tiger, tiger
```

-----------------------------------

### 문자열 전용 입출력 함수 : gets, puts
키보드로 데이터를 입력받을때는 scanf를 주로 사용했는데, 띄어쓰기가 있으면 그 띄어쓰기 전까지만 데이터에 저장하는 특징이있다.
gets 함수는 띄어쓰기를 포함해서 한 줄 전체를 입력받을 수 있다.
```C
// gets 함수 사용법
gets(char형 배열명);
gets(str)  // 빈칸을 포함한 문자열 입력
```
<br>
puts 함수는 문자열 상수나 char형 배열의 배열명을 주면 문자열을 화면에 출력한다. (printf 함수의 문자열 출력기능과 같다.) <br>
단, 문자열을 출력한 후에 자동으로 줄을 바꾸는 기능이 있기때문에 경우에따라 사용하면 될 것 이다.<br>
```C
// puts 함수 사용법
printf("%s\n", str); // printf로 문자열 출력 방법
puts(str);   // str에 문자열이 입력됬으면, str 문자열 출력
```

```C
// 빈칸을 이용한 문자열 입력과 출력을 확인하는 예제
#include<stdio.h>

int main() 
{
	char str[80];
	printf("문자열 입력 : ");  // 입력 안내 메세지 출력

	gets(str);                 // 빈칸을 포함한 문자열 출력

	puts("입력된 문자열 : ");  // 문자열 상수 출력

	puts(str);                 // 배열에 저장된 문자열 출력
	                           // puts 자동으로 개행시켜주는 특징이있다.
							   // 속도는 puts가 빠름.
	// printf는 상대적으로 무거움
	/*
       gets, puts는 컴파일러든지간에 지원이됨
	   scanf, printf는 지원안될수도있음 => 리소스가 적으면 부담스러움(많은 연산이 이뤄지기때문에)
	*/
	
	return 0;
}

// 결과
문자열 입력 : Love is belief...
입력된 문자열 :
Love is belief...
```
<br>
gets 함수는 엔터를 누르기 전까지 전체를 하나의 문자열로 배열에 저장해준다. (마지막에 NULL문자를 붙여서 문자열의 끝도 표시해준다.) <br>
gets 함수의 사용법은 간단하지만 입력할 배열의 크기를 검사하지 않으므로 배열의 크기보다 긴 문자열을 입력하면 메모리의 영역을 침범할 수도 있다. <br>
따라서 입력할때 항상 배열의 크기를 고려해주어야한다. <br>

#### 문자열의 끝에 NULL 문자가 없다면?
printf 함수를 비롯한 많은 문자열 처리 함수가 NULL문자로 문자열의 끝을 확인한다. <br>
따라서 char형 배열에 무엇을 저장하든 NULL 문자가 나올때까지가 하나의 문자열이다. 만약 필요한 곳에 NULL문자가 없다면 문자열 함수의 결과는 어떻게 될까?<br>

```C
// 문자열 특화함수 gets, puts
// printf, scanf가 %s, 변수를 입력해줘야하는데
// gets, puts 는 변수만 괄호안에넣어줘도 입력, 출력이 가능하다.

#include<stdio.h>

int main() 
{
	char str[5];

	str[0] = '0';
	str[1] = 'K';
	// str[2] = '\0';     // 2번방에 \0(Null문자)를 대입해주면 printf가 제대로 출력된다.
	
	printf("%s\n", str);

	// 문자 배열에는 항상 마침표로 null문자가 와야한다.
	// 마지막 5행의 배열이 초기화되지 않았으므로 배열에는 쓰레기값이 남아있다.
	// OK가 저장된 다음 요소에 널 문자가없어 쓰레기 값을 출력

	//null문자를 넣기가 귀찮으니까 처음에 문자열로 초기화를 시키는게 좋음
	// char str[5] = "OK";   // 이렇게 초기화하는게 더 편리함
	return 0;
}

// 결과
OK御御御御御御
```
char str[5]; 이 배열을 초기화하지 않았으므로 배열에는 쓰레기값이 남아있다. <br>
그 다음 'O', 'K' 를 넣어줬지만, 다른 방에는 쓰레기값이 들어있으므로 printf로 str을 출력하면 다른 쓰레기값이 같이 출력되는 것을 확인할 수 있다.<br>
심지어 할당된 배열에 NULL문자가 없으면 이어지는 메모리 영역까지 출력하기때문에 메모리 접근에러까지 발생하니 주의해야한다. <br>
따라서 문자열의 맨 끝에 NULL문자를 저장하는 것을 기억하자.<br>

-----------------------------------
