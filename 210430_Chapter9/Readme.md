## 9장 포인터
C는 메모리에 접근해서 우리가 원하는 방식으로 데이터를 사용할 수 있는 언어이다. <br>
지금까지 메모리에 접근하는 방법은 변수를 사용하는 것이었는데, 지금부터 메모리의 주소 값을 이용하는 '포인터'에 대해 알아보자. <br>

-----------------------------------------------

### 메모리의 주소
메모리는 우리가 데이터를 넣고 꺼내쓰는 공간으로, 그 위치를 식별할 수 있어야한다. <br>
(찬장 어딘가에 라면을 넣었는데 어디다 뒀는지 찾을 수 없다면 먹을 수 없는 것처럼 말이다.) <br><br>
C는 프로그램이 사용하는 메모리의 위치를 주소 값으로 식별할 수 있다. <br>
예를들어, int형 변수 a가 메모리 100번지부터 할당되었다면 100번지부터 103번지까지 4바이트에 걸쳐 할당된다. <br>
변수 선언 이후에는 4바이트 전체를 a라는 이름으로 사용하게 된다. <br>

#### 주소 연산자 : &
이제 저장된 공간을 이름이 아닌 주소로 사용하는 방법을 살펴보자. <br>
여기서 주소란, 변수가 할당된 메모리 공간의 시작 주소를 의미한다. 시작 주소를 알면 그 위치부터 변수의 크기만큼 메모리를 사용할 수 있다. <br>
```C
// 변수 메모리 주소 확인
#include <stdio.h>

int main() 
{
	// 변수 선언
	int a = 123456;
	double b = 12345678;
	char c = 'A';

	printf("int형 변수의 주소    : %p\n", &a);     // 주소 연산자로 주소계산
	printf("double형 변수의 주소 : %p\n", &b);  // %p로 주소를 출력할 수 있음.
	printf("char형 변수의 주소   : %p\n", &c);

	return 0;
}
// 결과
int형 변수의 주소    : 2750392
double형 변수의 주소 : 2750376
char형 변수의 주소   : 2750367
```
변수가 실행되면 자료형의 크기만큼 메모리에 저장 공간이 할당되는데, 주소 연산자 &로 변수를 피연산자로 사용하여 시작 주소를 구할 수 있다.<br>
예제를 통해 출력값을 살펴보면(끝에 2자리만 표현) <br>
int형 변수 a는 92-95 까지 4바이트 <br>
double형 변수 b는 76-83까지 8바이트  <br>
char형 변수 c는 67번지까지 할당된 것을 확인할 수 있다.<br>

-----------------------------------------------
### 포인터와 간접 참조 연산자 : *
변수에 할당된 메모리 주소를 활용하는 방법을 살펴보도록 하자.<br>
포인터는 메모리 주소를 저장하는 변수이다. <br>
메모리의 주소는 필요할때마다 계속 주소 연산을 수행하는 것보다 한 번 구한 주소를 저장해서 사용하는 것이 편리한데, 이때 포인터를 사용한다. <br>
따라서 주소를 저장할 포인터도 변수처럼 사용하면 된다.(이때 포인터를 선언할때는 변수 앞에 *를 붙여주면 된다)
```C
int *pa;   // 포인터 선언
pa = &a;   // 포인터 pa에 a의 주소 대입
```
<br>

포인터 pa는 변수 a가 메모리 어디에 할당됬는지 위치를 기억하고 있다.<br>
이렇게 포인터가 어떤 변수의 주소를 저장한 경우를 '가리킨다'하고 둘의 관계를 pa -> a 처럼 화살표로 간단하게 표현한다. <br>
만약 x -> y로 표현하면 'x는 y를 가리킨다'라고 말할 수 있고, x는 포인터이며 y의 주소를 저장하고 있다는 뜻이 된다. <br><br>

따라서, 포인터가 어떤 변수를 가리키면 포인터로 가리키는 변수를 사용할 수 있다. (포인터 pa로 변수 a를 사용할 수 있다)<br>
포인터가 가리키는 변수를 사용할 때는 포인터에 특별한 연산자를 사용하는데, 이를 간접 참조 연산자(*), 또는 포인터 연산자로 부른다.

```C
/*  
	포인터의 선언과 사용
	포인터를 사용할때는 변수명앞에 '*'를 붙여서 포인터 이름을 지을 수 있다.
	'*'는 포인터를 나타내는 표시이다.
	실행문에서 *pa는 pa를 가리키고있는 데이터를 나타낸다.
*/
#include <stdio.h>

int main()
{
	int a;      // 일반 변수 선언
	int *pa;    // ★포인터 선언★ (나는 포인터입니다. 를 나타내는 기호 '*'에 주목)

	pa = &a;    // 포인터변수에 a의 주소 대입(a의 주소를 pa에 대입)
	*pa = 10;   // ★포인터로 변수 a에 10 대입★
	// *pa는 데이터를 나타내는데, 이 데이터값에 10을 넣어라. 라는 뜻

	printf("변수명으로 pa 값 출력 : %p\n", pa);
	printf("포인터로 pa 값 출력   : %d\n", *pa);

	printf("a의 주소값 출력       : %p\n", &a);   // a의 값 출력
	printf("변수명으로 a 값 출력  : %d\n", a);    // 변수 a값 출력

	return 0;
}

// 결과
포인터로 a 값 출력   : 10
변수명으로 a 값 출력 : 10
```
<br>
이때 scanf를 사용할때를 생각해보자. <br>
scanf 함수는 입력할 변수가 메모리 어디에 할당되는지 저장 공간의 위치를 알아야한다. 따라서 변수의 주소를 인수로 줬었다. <br>
포인터 pa를 통해 변수 a에 입력할때도 마찬가지로 (*)pa는 a와 같기 때문에 &a는 &pa와 같다. <br>
즉, 간접참조 연산자로 pa가 가리키는 변수를 구하고 다시 주소 연산자로 주소를 구한다. <br>
하지만, pa가 a의 주소를 저장하므로 바로 pa를 사용해도 무방하다.<br>

```C
int a;
int *pa;
pa = &a;
scanf("%d", &a);   // &a로 변수 a의 저장공간 찾기
scanf("%d", pa);   // 포인터 pa 값은 &a
```

-----------------------------------------------


### 여러가지 포인터 사용
```C
/*
	'*' 가 사용될때는 선언부는 단순한 기호, 실행문에있는게 참조연산자
	pa가 주소를 저장한 포인터이기때문에 scanf를쓸때는 &를 안붙여줘도된다.
	int형 포인터에는 int변수, double형 포인터에는 double변수만 붙는다.
	포인터 변수 자체의 크기는 항상 실질적으로 4바이트이다.(int형, double 다 똑같음)
	=> 주소의 값이 변하지않기때문 
*/
// 포인터를 사용한 두 정수의 합과 평균 
#include<stdio.h>

int main() 
{
	int a = 10;
	int b = 15;
	int total;
	double avg;

	int *pa, *pb;       // int형 포인터 선언
	int *pt = &total;   // pt를 total의 int형 시작주소로 초기화
	double* pg = &avg;  // pg를 avg라는 double형 변수의 시작주소로 초기화


	// 포인터변수에는 주소를 저장
	pa = &a;  
	pb = &b;


	// 데이터를 넣을때 '*'를 사용함.
	*pt = *pa + *pb;   // pa, pb가 가리키고있는 두 값(a, b)을 더한다
	*pg = *pt / 2.0;


	printf("두 정수의 값   : %d, %d\n", *pa, *pb);   // a, b값 출력
	printf("두 정수의 합   : %d\n", *pt);            // total값 출력
	printf("두 정수의 평균 : %.2lf\n\n", *pg);       // avg값 출력

	printf("두 정수의 값   : %d, %d\n", a, b);
	printf("두 정수의 합   : %d\n", total);
	printf("두 정수의 평균 : %.2lf\n", avg);

	return 0;
}

// 결과
두 정수의 값   : 10, 15
두 정수의 합   : 25
두 정수의 평균 : 12.50

두 정수의 값   : 10, 15
두 정수의 합   : 25
두 정수의 평균 : 12.50
```
포인터가 어떤 변수를 가리키게 되면 그 이후에는 간접 참조 연산자를 통해 가리키는 변수를 자유롭게 사용할 수 있다.<br>
위의 예제에서  <br>
total의 포인터로 *pt, avg의 포인터로 *pg를 선언한 것을 확인할 수 있다.<br>
*pt = *pa + *pb; 를 통해 a값, b값을 더해 total에 저장되는 것처럼, <br>
일반 변수를 a, b, total, avg와 같은 이름으로도 사용할 수 있고, 그 변수들을 가리키는 각 포인터를 간접참조해도 사용할 수 있음을 보여준다.<br>

-----------------------------------------------

### const를 사용한 포인터
const 예약어를 포인터에 사용하면, 가리키는 변수의 값을 바꿀 수 없다는 의미로 사용되며 변수에 하는 것과는 다른 의미를 가진다.<br>
```C
/*
	포인터에 const 사용
	문자열 상수를 인수로 받는 함수에 주로 사용
	문자열 상수는 값이 바뀌면 안되는 저장 공간이므로 함수의 매개변수를 통해서
	값을 바꿀 수 없도록 const를 사용한다.(이건 12장에서 배울예정)
*/
#include <stdio.h>

int main() 
{
	int a = 10;
	int b = 20;
	const int* pa = &a;               // 포인터 pa는 변수 a를 가리키며 const를통해 상수화
	// 포인터가 가리키는 곳의 데이터를 상수화
	// => 데이터 직접대입은 불가능, 가리키는 곳은 바꿀수있어서 출력할때 값을 다르게할수는있음.

	int* const pb = &b;               // a와는 다르게 const의 위치를 다르게 선언
	// 포인터 자체가 상수화 
	// => 다른 주소값을 넣을 수 없음, pb자체의 데이터는 변경할수는있음

	printf("변수 a 값 : %d\n", *pa);  // 포인터를 간접 참조하여 a출력
	pa = &b;                          // 포인터가 변수 b를 가리킴

	printf("변수 b 값 : %d\n", *pa);  // 포인터를 간접참조하여 b출력
	pa = &a;                          // 포인터가 변수 a를 가리킴

	a = 20;                           // a를 직접 참조하여 값을 바꾼다.
	printf("변수 a 값 : %d\n", *pa);  // 포인터로 간접 참조하여 바뀐 값 출력

	//pa = 30;						  // 포인터변수 pa에 30 직접 대입
	//printf("변수 a 값 : %d\n", *pa);  // pa는 const라서 값이 변하지않기때문에 바꾸려고하니 오류뜸
	 
	// -------------------------------------------------------------------------------------

	return 0;
}
// 결과
변수 a의 값 : 10
변수 b의 값 : 20
변수 a의 값 : 20
```
위의 예제에서 포인터 pa를 선언할때 const로 상수화했는데, 만약 const가 일반 변수처럼 포인터 값을 고정시킨다면 pa는 다른 변수의 주소를 저장할 수 없다. <br>
그러나 출력 결과에서 pa는 const사용과 무관하게 변수 b의 주소를 저장하고 그 값을 간접 참조하여 출력하고있다.<br>

이때 포인터에서 사용된 const는 pa가 가리키는 변수 a가 pa를 간접참조하여 바꿀 수 없다는 것을 뜻한다. <br>
만약 주석처리된 pa = 30; 을 통해 a값을 바꾸려고하면 pa가 const라서 값이 변하지않기 때문에 에러가 뜰것이다.<br><br>

따라서 포인터는 <br>
- 메모리를 사용하는 또 다른 방법
- 주소 연산자 &로 변수가 할당된 메모리의 위치를 확인 
- 포인터로 가리키는 변수를 사용할때 간접참조연산자 *를 쓴다. <br>
라는 사실을 기억하도록 하자.

-----------------------------------------------

### 주소와 포인터의 차이
주소는 변수에 할당된 메모리 저장 공간의 시작 주소 값 자체 <br>
포인터는 그 값을 저장하는 또 다른 메모리 공간이다. <br>
따라서 특정 변수의 주소 값은 바뀌지 않지만, 포인터는 다른 주소를 대입하여 그 값을 바꿀 수 있다. <br>
```C
int a, b;  // 일반 변수 선언
int *p;    // 포인터 선언
p = &a;    // p가 a를 가리키도록 설정
p = &b;    // p가 b를 가리키도록 설정
```
이처럼 포인터 p에 a, b중 어떤 주소를 대입하느냐에 따라 가리키는 변수가 바뀌게 된다. <br>
이 말은, 한마디로 주소는 '상수'이고, 포인터는 '변수' 라는 것을 확인할 수 있다. <br>

```C
int a;             
int *pa, *pb;      // 가리키는 자료형(int형)이 같은 두 포인터
pa = pb = &a;      // pa와 pb에 모두 a의 주소 저장
*pa = 10;          // pa가 가리키는 변수 a에 10 대입
printf("%d", *pb); // pb가 가리키는 변수 a값 10 출력
```

주소도 포인터처럼 간접 참조 연산자를 쓸 수는 있지만 상수이므로 대입 연산자 왼쪽에 올 수 없다. <br>
즉, 상수와 변수는 용도가 분명이 다르기때문에 주소와 포인터는 서로 구분하여 이해하는 것이 좋을 것이다. <br>

```C
&a = &b;  // a의 주소를 b의 주소로 바꾸는 건 불가능(에러)
```

-----------------------------------------------

### 주소와 포인터의 크기
포인터도 저장 공간이므로 그 크기가 있다. 모든 주소와 포인터는 가리키는 자료형과 상관 없이 크기가 같다. <br>
sizeof 연산자를 통해 주소와 포인터의 크기를 알아보자. <br>
```C
#include <stdio.h>

int main() {
	char ch;
	int in;
	double db;

	char* pc = &ch;
	int* pi = &in;
	double *pd = &db;

	// 주소 크기는 항상 4바이트
	printf("char형   변수의 주소 크기 : %d\n", sizeof(&ch));
	printf("int형    변수의 주소 크기 : %d\n", sizeof(&in));
	printf("double형 변수의 주소 크기 : %d\n\n", sizeof(&db));

	// 포인터의 크기는 항상 4바이트
	printf("char *   포인터의 크기 : %d\n", sizeof(pc));
	printf("int *    포인터의 크기 : %d\n", sizeof(pi));
	printf("double * 포인터의 크기 : %d\n\n", sizeof(pd));

	// 변수의 크기는 변수의 타입에따라 다르게 출력
	printf("char *   포인터가 가리키는 변수의 크기 : %d\n", sizeof(*pc));
	printf("int *    포인터가 가리키는 변수의 크기 : %d\n", sizeof(*pi));
	printf("double * 포인터가 가리키는 변수의 크기 : %d\n\n", sizeof(*pd));

	return 0;
}
// 결과
char형   변수의 주소 크기 : 4
int형    변수의 주소 크기 : 4
double형 변수의 주소 크기 : 4

char *   포인터의 크기 : 4
int *    포인터의 크기 : 4
double * 포인터의 크기 : 4

char *   포인터가 가리키는 변수의 크기 : 1
int *    포인터가 가리키는 변수의 크기 : 4
double * 포인터가 가리키는 변수의 크기 : 8
```
ch, in, db는 각각 변수 자체의 크기는 다르지만 그 시작 주소 값의 크기는 같다는 것을 알 수 있다. <br>
따라서 포인터는 가리키는 자료형과 상관없이 모두 크기가 같다. <br>
포인터에 간접 참조 연산자를 사용하여 가리키는 변수의 크기를 출력하면 각각의 자료형의 크기가 출력된다. <br>

-----------------------------------------------

### 포인터의 대입 규칙
포인터는 크기가 모두 같으므로 대입 연산을 쉽게 생각할 수 있는데, 규칙에 따라 제한적으로 사용해야 한다.<br>

#### 규칙1 : 포인터는 가리키는 변수의 형태가 같을때만 대입해야 한다.
포인터끼리 대입 연산을 수행하면 여러 개의 포인터로 같은 데이터를 다루는 것이 가능하다.<br>
그러나 규칙을 지키지 않는 대입 연산은 그 결과를 예상할 수 없다.<br>
```C
#include <stdio.h>

int main() 
{
	int a = 10;
	int* p = &a;
	//int* pd;
	double* pd;

	pd = p;					// 주소값 넣는거는 문제가없음
	//printf("%d\n", *pd);
	printf("%lf\n", *pd);   // 데이터에 접근하는 것은 문제가됨
	
	return 0;
}
// 결과
-92559592117432107884277659021957555520241347761778250032873472.000000
```
컴파일러는 p에 저장된 값을 int형 변수의 주소로 생각하고, pd에 저장된 값을 double형 변수의 주소로 생각한다. <br>
따라서 pd에 p를 대입한 후에 간접 참조 연산을 수행하면 변수 a에 할당된 영역 이후의 할당되지 않은 영역까지 사용하게 된다. <br><br>

pd를 통해 간접참조연산을 수행하면 메모리 100번지부터 107번지까지 8바이트를 하나의 double형 변수로 생각하고 그 값을 실수 값으로 해석하므로 알 수 없는 결과를 출력한다. <br>


-----------------------------------------------



-----------------------------------------------

-----------------------------------------------
